# 12.06 알고리즘 문제풀이

21921 블로그
2668 숫자고르기

## 🔍 진행 방식

### BOJ_2075 N번째 큰수 

- 문제를 봤을 때 데이터 값의 범위나, 전체 범위에 특이사항이 없었다고 느꼈고,
- 크기 순대로 정렬해서 원하는 size의 인덱스 값 만 뽑으면 되므로
- 일일히 값을 넣었을 때 정렬해주는 것 보다 우선순위 큐를 사용하면 편하다고 생각함


### BOJ_1027 고층 건물

- 문제를 봤을 때 높이의 값이 10억 이하라서 일단 int는 쓰면 안된다고 생각했고, 
- 건물을 지나가면서 기준 index를 잡고 왼쪽 오른쪽으로 보면 어떨까 생각이 났음
- 왼쪽으로 볼 때는 전의 최대 기울기보다 작게, 오른쪽으로 볼 때는 전의 최대 기울기보다 크게 라는 포인트까지 찾음.

```
문제 =>  long vs double (문제는 -> 예제1이었음)

찾아낸 것은 설마 매우 작은 값의 비교를 잡지 못해서 지나치지 않을까 하는 생각에 long과 double의
값을 나타낼 수 있는 검색을 통해 double이 더 넓게 표현하는 것을 알고 long에서 double로 바꿨더니
정답이었다.
```


### BOJ_21921 블로그

- 문제를 봤을 때 단순하게 모두 계산하면 당연히 시간초과를 내는 듯한 문제처럼 보였다
- 해당 범위를 더하면서 맨 끝값만 계산하면 될 것 같다고 생각해서 이대로 풀이했던 것 같다.


### BOJ_2668 숫자고르기

- 문제를 읽는데 처음부터 이해가 되지 않아 고난을 겪은 문제
- 문제의 이해를 돕고자 다른 블로그를 참고하였고, 기초 DFS문제라는 힌트를 얻어 시도했지만,
- 실패하여 코드를 참고하여 이해한 문제이다.


### BOJ_7490 0 만들기

- 문제를 읽는데 모든 경우의 수를 다 따져보고 계산 값이 0인지 구하는 것을 파악했다
- 어려웠던 것은 "+","-"," " 을 어떻게 바꿔주면서 값을 계산할지와 공백일 때 숫자를 붙여갈지 고민이었다.
- dfs 함수를 통해 해당 N까지 값이 나올때까지 +,-," "을 처리해주면서 cal 함수로 계산하며 0일때 를 구해주었다.


