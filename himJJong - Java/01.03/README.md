# 01.03 알고리즘 문제풀이

## 🔍 진행 방식

### BOJ_2164 카드2

- 문제를 읽고 컬렉션을 활용하여 동적 배열을 이용한다면 쉽게 풀 수 있겠다고 생각이 들었고
- while문을 통해 리스트의 사이즈가 1일때 까지
- 한번은 맨 위에서 제거, 한번은 맨 위 값을 맨 아래에 추가 삽입하여 해결했다
- 
### BOJ_20922 겹치는건 싫어

- 문제를 읽었을 때 data값의 배열과 check 해주기 위한 배열로, 범위 내의 값에 있을 때마다 최댓값을 구하도록 해결했다. 
- 그것이 주석처리한 아래 코드인데, 문제에 주어져 있던 다른 테케를 통과함에도 시간초과가 났다 이유는 O(N^2)이라
- 그래서 아래의 알고리즘 종류를 확인해보니 투 포인터 문제였고, start와 end를 두어 O(N)으로 해결했다


### BOJ_13144 List of Unique Numbers

- 문제를 읽었을 때 연속된 수를 겹치는거 없도록 체크해줘야 하므로 이를 위해 check 배열을 만들었다.
- 한 번의 체크로 start와 end를 확인해가며 start-end+1을 통해 구하는 것이 핵심이었던 것 같다.
- 잘못된 생각의 흐름은 아래와 같다.

```
< 메인 로직만 > 
첫번째 시도 (시간초과)

while(start != num) {
     while (end <= data.length-1 && check[data[end]] == 0) {
            check[data[end]]++;
            end++;
            answer++;
        }
        Arrays.fill(check, 0);
        start++;
        end = start;
}

위는 1 2 3 1 2 가 있다면 start와 end 모두를
1) 1부터 시작해서 겹치는게 없을 때까지 answer++
2) 다시 2부터 시작해서 겹치는게 없을 때까지 answer++

이렇게 해서 끝까지 돌아가는 식이었다. 결국 O(N^2)

=========================================================

두 번째 시도 (메모리 초과 && 시간초과)

while(start != num) {
     int[] check = new int[max+1];
     while (end <= data.length-1 && check[data[end]] == 0) {
          check[data[end]]++;
          end++;
          answer++;
     }
     start++;
     end = start;
}

로직이 잘못된것을 인지 못하고, Arrays.fill의 시간복잡도 때문에 생긴 문제가 아닐까 생각들어서
while문을 돌때마다 배열을 다시 초기화 해줬는데 잘못된 방법이었다.
     
```
