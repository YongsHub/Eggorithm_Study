# 11.29 알고리즘 문제풀이

## 🔍 진행 방식

### 19637_IF문 좀 대신 써줘

- 첫번째 풀이 : HashMap을 이용하여 등급과 값을 저장하고, 해당 데이터를 비교 - 시간초과오류
- 두번째 풀이 : 정렬되어있는 값과 범위를 통해 이분탐색을 사용하여 다시 적용하였지만, 아래 이유로 오류 수정


```
answer.add(gradeName[left]); -> );
answer.forEach(System.out::println);

         ||
         ||
                
bw.write(gradeName[left]+"\n");
bw.flush();

*입력 뿐 아니라 출력이 많을 때도 시간이 오래 걸린다는 점에서 BufferWriter도 사용할 줄 알아야했다.
```

```
추가로 

Arrays.sort : 퀵 정렬 / 최악일 경우 O(n^2) 이지만,
Collections.sort() : Timsort - Timsort란 삽입 정렬과 합병정렬을 결합하여 만든 정렬 / 최악일 경우 O(nlog(n)) 

시간 복잡도가 다른것은 알고 있었지만 조금 자세하게 나와있어 자바를 공부하는 친구들을 위해 넣어놓았다. 궁금하면 아래 링크로 가서 읽어봐도 재밌을거다.
https://laugh4mile.tistory.com/175
```


### 2304_창고다각형 

- 무작위로 주어진 데이터 값을 x축의 값들로 정렬
- 현재 기둥과 그 뒤의 기둥을 확인해가면서 최소 직사각형 넒이 구하기, 범위가 모두 <=1000이라 시간초과가 나지 않는다는 것을 근거로 생각
- 나머지는 비교하면서 식 찾기

```
추가로

Arrays.sort(arr, new Comparator<int[]>() {
    @Override
    public int compare(int[] o1, int[] o2) {
        return o1[0]-o2[0]; // 첫번째 숫자 기준 오름차순 {1,30}{2,10}{3,50}{4,20}{5,40}
        //return o2[0]-o1[0]; // 첫번째 숫자 기준 내림차순 {5,40}{4,20}{3,50}{2,10}{1,30}
        //return o1[1]-o2[1]; // 두번째 숫자 기준 오름차순 {2,10}{4,20}{1,30}{5,40}{3,50}
        //return o2[1]-o1[1]; // 두번째 숫자 기준 내림차순 {3,50}{5,40}{1,30}{4,20}{2,10}
    }
});
```

### 1943_동전분배

- 처음에 그리디 문제인 줄 알았지만 무언가 계속 꼬이고, 생각대로 풀리지 않음
- DP문제인 것을 확인 후 점화식을 고민하는데 해결되지 않아 블로그를 참고하여 공부함

```
추가로

DP의 기본문제인 냅색문제인데, dp를 2차원 배열로 풀고 1차원 배열로 리팩토링 하는 과정이 자세하게 나와있어 좋았던 블로그였기에 올려놓음.
https://chanhuiseok.github.io/posts/improve-6/
```
